---
title: 第二章:进程和线程
date: 2020-8-14
tags: 
  - 考研
  - 计算机操作系统
author: pasre
location: Suzhou  
---

## 一、 进程的定义、组成、组织方式、特征
### 1.1 进程的定义
  <font color="red">程序段、数据段、PCB</font>三部分组成了<font color="red">进程实体</font>（<font color="red">进程映像</font>）。  
  <font color="red">PCB是进程存在的唯一标志！</font>  

  从不同的角度、进程可以有不同的定义，比较传统典型的定义有：
  > 进程是程序的一次<font color="blue">执行过程</font>  
  > 进程是一个程序及其数据在处理机上顺序执行时所<font color="blue">发生的活动</font>。   
  > 进程是具有独立功能的程序在数据集合上<font color="blue">运行的过程</font>，它是系统进行资源分配和调度的一个独立单位

  <font color="red">进程</font>是进程实体的<font color="blue">运行过程</font>，是系统进行<font color="red">资源分配</font>和<font color="red">调度</font>的一个独立单位。  
  严格来说，进程实体和进程并不一样，进程实体是<font color="red">静态的</font>，进程则是<font color="red">动态的</font>。

### 1.2 进程的组成
  进程（进程实体）有<font color="red">程序段、数据段、PCB</font>三部分组成。  

  <details>
    <summary><font color="pink">PCB</font></summary>

  * 进程描述信息
    > 进程标识符PID  
    > 用户标识符UID  

  * 进程控制和管理信息
    > 进程当前状态  
    > 进程优先级  

  * 资源分配清单
    > 程序段指针  
    > 数据段指针  
    > 键盘  
    > 鼠标

  * 处理机相关信息
    > 各种寄存器值
  
  </details>

  <font color="pink">程序段</font> `存放要执行的代码`  

  <font color="pink">数据段</font> `存放程序运行过程中处理的各种数据`
  

### 1.3 进程的组织
  `执行指针` `就绪队列指针` `阻塞队列指针`  

  * 链接方式 
    > 按照进程状态将PCB分为多个队列  
    > 操作系统持有指向各个队列的指针

  * 索引方式
    > 根据进程状态的不同，建立几张索引表  
    > 操作系统持有指向各个索引表的指针

### 1.4 进程的特征

  * 动态性 `进程是程序的一次执行过程，是动态的产生、变化和消亡的`
  * 并发性 `内存中有多个进程实体、各进程可并发执行`
  * 独立性 `进程是能独立运行、独立获得资源、独立接受调度的基本单位`
  * 异步性 
    > 各进程按各自独立的、不可预知的速度向前推进  
    > 操作系统要提供"进程同步机制"来解决异步问题
  * 结构性 `每个进程都会配置一个PCB。结构上看，进程由程序段、数据段、PCB组成`

## 二、进程的状态与转换

### 2.1 进程的状态
  * 运行态 `占有CPU，并在CPU上运行`
  * 就绪态 `已经具备运行条件，但由于没有空闲CPU，而暂时不能运行`
  * 阻塞态(等待态) `因等待某一事件而暂时不能运行`

  * 创建态(新建态) `进程正在被创建，操作系统为进程分配资源、舒适化PCB`
  * 终止态(结束态) `进程正在从系统中撤销，操作系统会回收进程拥有的资源、撤销PCB`

### 2.2 进程状态的转换
  阻塞态 → 就绪态 不是进程自身能控制的，是一种<font color="red">被动行为</font>。  
  运行态 → 阻塞态 是一种进程自身做出的<font color="red">主动行为</font>  

  <font color="red">不能由阻塞态直接转换为运行态，也不能由就绪态直接转换为阻塞态</font>（进入阻塞态是进程主动请求的，必须进程在运行时才能发出这种请求）

  > 就绪态 → 运行态 `进程被调度`  
  > 运行态 → 就绪态 `时间片到，或CPU被其他高优先级的进程抢占`  
  > 运行态 → 阻塞态 `等待系统资源分配，或等待某事件发生(主动行为)`  
  > 阻塞态 → 就绪态 `资源分配到位，等待的世界发生(被动行为)`  
  > 创建态 → 就绪态 `系统完成创建进程相关的工作`  
  > 运行态 → 终止态 `进程运行结束，或运行过程中遇到不可修复的错误`

## 三、进程控制

### 3.1 基本概念
  进程控制的主要功能是对系统中的所有进程实施有效的管理，它具有创建新进程、撤销已有进程、实现进程状态转换等功能。  

  用<font color="red">原语</font>实现进程控制。原语的<font color="red">特点</font>是执信期间<font color="red">不允许中断</font>，只能一气呵成。  
  这种不可被中断的操作即为<font color="red">原子操作</font>  
  原语采用<font color="red">关中断</font>、<font color="red">开中断</font>指令实现（只能运行在<font color="red">核心态</font>）

### 3.2 进程控制相关的原语

  <details>
    <summary><font color="pink">进程的创建</font></summary>
    
  * 创建原语
    > 申请空白PCB  
    > 为新进程分配所需资源  
    > 初始化PCB  
    > 将PCB插入就绪队列
  
  * 引起进程创建的事件
    > 用户登录 `分时系统中，用户登录成功，系统会为其建立一个新的进程`  
    > 作业调度 `多道批处理系统中，有新的作业放入内存时，会为其建立一个新的进程`  
    > 提供服务 `用户向操作系统提出某些请求时，会新建一个进程处理该请求`  
    > 应用请求 `由用户进程主动请求创建一个子进程`
    
  </details>

  <details>
    <summary><font color="pink">进程的终止</font></summary>
    
  * 撤销原语
    > 从PCB集合中找到终止进程的PCB  
    > 若进程正在运行，立即剥夺CPU，将CPU分配给其他进程  
    > 终止其所有子进程  
    > 将该进程拥有的所有资源归还给父进程或操作系统  
    > 删除PCB
  
  * 引起进程终止的事件
    > 正常结束  
    > 异常结束  
    > 外界干预
    
  </details>

  <details>
    <summary><font color="pink">进程的阻塞和唤醒</font></summary>
    
  * 进程的阻塞
    + 阻塞原语
      > 找到要阻塞的进程对应的PCB  
      > 保护进程运行现场，将PCB状态信息设置为“阻塞态”，暂时停止进程运行  
      > 将PCB插入相应事件的等待队列
    
    + 引起进程阻塞的事件
      > 需要等待系统分配某种资源  
      > 需要等待相互合作的其他进程完成工作

  * 进程的唤醒
    + 唤醒原语 
      > 在事件等待队列中找到PCB  
      > 将PCB从等待队列移除，设置进程为就绪态  
      > 将PCB插入就绪队列，等待被调度

    + 引起进程唤醒的事件
      > 等待的事件发生
    
  </details>

  <details>
    <summary><font color="pink">进程的切换</font></summary>
    
  * 切换原语
    > 将运行环境信息存入PCB  
    > PCB移入相应队列  
    > 选择另一个进程执行，并更新其PCB  
    > 根据PCB恢复新进程所需的运行环境

  * 引起进程切换的事件
    > 当前进程时间片到  
    > 有更高优先级的进程到达  
    > 当前进程主动阻塞  
    > 当前进程终止
    
  </details>

  
## 四、进程通信

### 4.1 什么是进程通信
  进程是分配系统资源的基本单位(包括内存地址空间)，因此<font color="red">各进程</font>拥有的<font color="red">内存地址空间相互独立</font>  

  为了保证安全，<font color="red">一个进程不能直接访问另一个进程的地址空间</font>。
  
### 4.2 共享存储
  两个进程对共享空间的<font color="red">访问</font>必须是<font color="red">互斥</font>的

  <font color="red">基于数据结构</font>的共享：速度慢，限制多，是一种<font color="red">低级通信</font>方式  

  <font color="red">基于存储区</font>的共享： 速度更快，是一种<font color="red">高级通信</font>方式

### 4.3 管道通信
  1. 管道只能采用<font color="red">半双工通信</font>,某一时间段内只能实现单向的传输。如果要实现<font color="red">双向同时通信</font>，则<font color="red">需要设置两个管道</font>。  
  2. 各进程要<font color="red">互斥</font>地访问管道。  
  3. 数据以字符流的形式写入管道，当<font color="red">管道写满</font>时，<font color="red">写进程</font>的write()系统调用将被<font color="red">阻塞</font>，等待读进程将数据取走。当读进程将数据全部取走后，<font color="red">管道变空</font>，此时<font color="red">读进程</font>的read()系统调用将被<font color="red">阻塞</font>。  
  4. 如何<font color="red">没写满，就不允许读</font>。如果<font color="red">没读空，就不允许写</font>。
  5. 数据一旦被读出，就从管道中被抛弃，这就意味着<font color="red">读进程最多只能有一个</font>，否则可能会有读错数据的情况。

### 4.4 消息传递
  进程间的数据交换以<font color="red">格式化的消息</font>为单位。进程通过操作系统提供的“发送消息/接收消息”两个<font color="red">原语</font>进行数据交换

  > 直接通信方式 `消息直接挂到接收进程的消息缓冲队列上`  
  > 间接通信方式 `消息要先发送到中间实体(信箱)中`


## 五、线程概念和多线程模型

### 5.1 什么是线程，为什么要引入线程？
  有的进程可能需要“同时”做很多事，而传统的进程只能串行地执行一系列程序。为此，引入了“线程”，来增加并发度。  
  传统的进程是程序执行流的最小单位  
  引入线程后，线程成为了程序执行流的最小单位  

  <font color="red">线程</font>是一个<font color="red">基本的CPU执行单元</font>，也是<font color="red">程序执行流的最小单位</font>。

### 5.2 引入线程机制后，有什么变化？
  * 资源分配、调度
    > 传统进程中，进程是资源分配、调度的基本单位  
    > 引入线程后，进程是资源分配的基本单位，线程是调度的基本单位

  * 并发性
    > 传统进程机制中，只能进程间并发  
    > 引入线程后，各线程间也能并发，提升了并发度

  * 系统开销
    > 传统的进程间并发，需要切换进程的运行环境，系统开销很大  
    > 线程间并发，如果是同一进程内的线程切换，则不需要切换进程环境，系统开销小  
    > 引入进程后，并发所带来的系统开销减小

### 5.3 线程的属性
  > 线程是处理机调度的单位  
  > 多cpu计算机中，各个线程可占用不同的CPU  
  > 每个线程都要一个线程ID、线程控制看（TCB）  
  > 线程也有就绪、阻塞、运行三种基本状态  
  > 线程几乎不拥有系统资源  
  > 同一进程的不同线程共享进程的资源  
  > 由于共享内存地址空间，同一进程中的线程间通信甚至无需系统干预  
  > 同一进程中的线程切换，不会引起进程切换  
  > 不同进程中的线程切换，会引起进程切换  
  > 切换同进程内的线程，系统开销很小  
  > 切换进程，系统开销很大

### 5.4 线程的实现方式
  * 用户级线程（User-Level Thread,ULT）  
    用户级线程由应用程序通过线程库实现。  
    所有的<font color="red">线程管理工作</font>都由<font color="red">应用程序负责</font>(包括线程切换)  
    用户级线程中，<font color="red">线程切换</font>可以在<font color="red">用户态下即可完成</font>，无需操作系统干预。  
    <font color="red">“用户级线程”</font>就是<font color="red">“从用户视角看能看到的线程”</font>

  * 内核级线程（Kernel-Level,KLT 又称“内核支持的线程”）  
    内核级<font color="red">线程的管理工作</font>由<font color="red">操作系统内核</font>完成。
    线程调度、切换等工作都由内核负责，因此<font color="red">内核级线程的切换</font>必然需要在<font color="red">核心态</font>下才能完成。  
    <font color="red">“内核级线程”</font>就是<font color="red">“从操作系统内核视角看能看到的线程”</font>

  操作系统只“看得见” 内核级线程，因此只有<font color="red">内核级线程才是处理机分配的单位</font>。

### 5.5 多线程模型
  * <font color="red">多对一</font>模型  
    `多个用户及线程映射到一个内核级线程。每个用户进程只对应一个内核级线程。`

    <font color="blue">优点</font>: 用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高  
    <font color="blue">缺点</font>：当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。多个线程不可在多核处理机上并发运行

  * <font color="red">一对一</font>模型  
    `一个用户级线程映射到一个内核级线程。每个用户进程都有与用户级线程同数量的内核级线程。`  

    <font color="blue">优点</font>：当一个线程被阻塞后，别的线程还可以继续运行，并发能力强。多线程可在多核处理机上并发执行。  
    <font color="blue">缺点</font>：一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大。

  * <font color="red">多对多</font>模型  
    `n用户级线程映射到m个内核级线程(n > m)。每个用户进程对应m个内核级线程。`  

    克服了多对一模型并发度不高的缺点，又克服了一对一模型中一个用户进程占用太多内核级线程，开销太大的缺点。

## 六、处理机调度的概念、层次

### 6.1 调度的基本概念
  当有一堆任务要处理，但由于资源有限，这些事情没法同时处理。这就需要确定<font color="red">某种规则</font>来<font color="red">决定</font>处理这些任务的<font color="red">顺序</font>，这就是“调度”研究的问题。  

  在多道程序系统中，进程的数量往往是由多于处理机的个数的，这样不可能同时并行地处理各个进程。  
  <font color="red">处理机调度</font>，就是从就绪队列中<font color="red">按照一定的算法选择一个进程</font>并<font color="red">将处理机分配给它</font>运行，以实现进程的并发执行。

### 6.2 调度的三个层次

  * <font color="blue">高级调度</font>

    <font color="red">高级调度（作业调度）</font>。按一个的原则从外存上处于后背队列的作业中挑选一个（或多个）作业，给他们分配内存等必要资源，并<font color="red">建立相应的进程（建立PCB）</font>，以使它（们）<font color="red">获得竞争处理机的权利</font>。  
    高级调度是辅存（外存）与内存之间的调度。每个作业只调入一次，调出一次。<font color="red">作业调入时会建立对应的PCB，作业调出时才撤销PCB</font>。高级调度主要是指调入的问题，因为只有调入的时机需要操作系统来确定，但调出的时机必然是作业运行结束才调出。

  * <font color="blue">中级调度</font>

    引入了虚拟内存技术后，可将暂时不能运行的进程调至外存等待。等它重新具备了运行条件且内存又稍有空闲时，再重新调入内存。  
    这么做的目的是为了<font color="red">提高内存利用率</font>和<font color="red">系统吞吐量</font>。  

    暂时调到外存等待的进程状态为<font color="red">挂起状态</font>。值得注意的是，<font color="red">PCB</font>并不会一起调到外存,而是<font color="red">会常驻内存</font>。PCB中会记录进程数据在外存中的存放位置，进程状态等信息，操作系统通过内存中的PCB来保持对各个进程的监控、管理。被挂起的进程PCB会被放到<font color="red">挂机队列</font>中。  

    <font color="red">中级调度（内存调度）</font>，就是要决定将哪个处于挂起状态的进程重新调入内存。  
    一个进程可能会被多次调出、调入内存，因此<font color="red">中级调度</font>发生的<font color="red">频率</font>要比高级调度<font color="red">更高</font>。

 * <font color="blue">低级调度</font>

    <font color="red">低级调度（进程调度）</font>，其主要任务是按照某种方法和策略从就绪队列中选取一个进程，将处理机分配给它。

    进程调度是操作系统中<font color="red">最基本的一种调度</font>，在一般的操作系统中都必须配置进程调度。

    进程调度的<font color="red">频率很高</font>，一般几十毫秒一次。

### 6.3 三层调度的联系、对比
  |<div style="width: 75px">调度层次</div>|要做什么|<div style="width: 88px">调度发生在...</div>|频率|<div style="width: 140px">对进程状态的影响</div>|
  |:--:|--|--|--|--|
  |高级调度(作业调度)|按照某种规则，从后背队列中选择合适的作业将其调入内存，并为其创建进程|外存 → 内存(面向作业)|最低|无 → 创建态 → 就绪态|
  |中级调度(内存调度)|按照某种规则，从挂起队列中选择合适的进程将其数据调回内存|外存 → 内存(面向进程)|中等|挂起态 → 就绪态(阻塞挂机 → 阻塞态)|
  |低级调度(进程调度)|按照某种规则，从就绪队列中选择一个进程为其分配处理机|内存 → CPU|最高|就绪态 → 运行态|


## 七、处理机调度的时机、切换与过程、方式

### 7.1 进程调度的时机
  <font color="red">进程调度</font>(低级调度)，就是按照某种算法从就绪队列中选择一个进程未其分配处理机。  

  * <font color="red">需要进行</font>进程调度与切换
    + 当前运行进程<font color="red">主动放弃</font>处理机
      > 进程正常终止  
      > 运行过程中发生异常而终止  
      > 进程主动请求阻塞

    + 当前运行进程<font color="red">被动放弃</font>处理机
      > 分给进程的时间片用完  
      > 有更紧急的事需要处理  
      > 有更高优先级的进程进入就绪队列

  * <font color="red">不能进行</font>进程调度与切换
    1. 在<font color="red">处理中断的过程中</font>。中断处理过程复杂，与硬件密切相关，很难做到在中断处理过程中进行进程切换。  
    2. 进程在<font color="red">操作系统内核程序临界区</font>中。  
    3. 在<font color="red">原子操作过程中</font>（原语）。原子操作不可中断，要一气呵成。


  进程在<font color="red">操作系统内核程序临界区</font>中<font color="red">不能</font>进行调度与切换

### 7.2 进程调度的方式
  * <font color="red">非剥夺调度方式</font>，又称<font color="red">非抢占方式</font>。即，只允许进程主动放弃处理机。在运行过程中即使有更紧迫的任务到达，当前进程依然会继续使用处理机，直到该进程终止或主动要求进入阻塞态。  
  `实现简单、系统开销小但是无法及时处理紧急任务，合适于早期的批处理系统`


  * <font color="red">剥夺调度方式</font>，又称<font color="red">抢占方式</font>。当一个进程正在处理机上执行时，如果有一个更重要或更紧迫的进程需要使用处理机，则立即暂停正在执行的进程，将处理机分配给更重要紧迫的那个进程。  
  `可以优先处理更紧急的进程，也可实现让各进程按时间片轮流执行的功能（通过时钟中断）。适合于分时操作系统、实时操作系统`

### 7.3 进程的切换与过程
  <font color="red">狭义的进程调度</font>是指从就绪队列中<font color="red">选中一个要执行的进程</font>。（这个进程可以是刚刚被暂停执行的进程，也可以是<font color="red">另一个进程</font>，后一种情况就需要<font color="red">进程切换</font>）  
  <font color="red">进程切换</font>是指一个进程让出处理机，由另一个进程占用处理机的过程。  

  <font color="red">广义的进程调度</font>包含了选择一个进程和进程的切换两个步骤。
  
  <details>
    <summary><font color="pink">切换的过程</font></summary>
    
  1. 对原来运行进程各种数据的保存 
  2. 对新的进程各种数据的恢复
    
  </details>

  <font color="blue">注意</font>：<font color="red">进程切换是有代价的</font>，因此如果<font color="red">过于频繁</font>的进行进程<font color="red">调度、切换</font>，必然会使整个<font color="red">系统的效率降低</font>，使系统大部分时间都花在进程切换上，而真正用于执行过程的时间减少。
  
  
## 八、调度算法的评价指标

### 8.1 CPU利用率
  <font color="red">CPU利用率</font>：指CPU“忙碌”的时间占总时间的比例  
  <font color="red">利用率</font> = 忙碌的世界 / 总时间

### 8.2 系统吞吐量
  <font color="red">系统吞吐量</font>：单位时间内完成作业的数量  
  <font color="red">系统吞吐量</font> = 总共完成了多少道作业 / 总共花了多少时间

### 8.3 周转时间
  * <font color="red">周转时间</font>，指<font color="red">作业从被提交到系统开始</font>，到<font color="red">作业完成未止</font>的这段时间间隔  
  （作业）<font color="red">周转时间</font> = 作业完成时间 - 作业提交时间  
    <font color="red">平均周转时间</font> = 各作业周转时间之和 / 作业数

  * <font color="red">带权周转时间</font> = 作业周转时间 / 作业实际运行时间 = (作业完成时间 - 作业提交时间) / 作业实际运行的时间  
    <font color="red">平均带权周转时间</font> = 各作业带权周转时间之和 / 作业数  
    带权周转时间必然 >= 1  
    带权周转时间和周转时间都是越小越好

### 8.4 等待时间
  <font color="red">等待时间</font>，值进程/作业<font color="red">处于等待处理机状态时间之和</font>，等待时间越长，用户满意度越低  

  对于<font color="red">进程</font>来说，等待时间就是指进程建立后<font color="red">等待被服务的时间之和</font>，在等待I/O完成的期间其实进程也是在被服务的，所以不计入等待时间。  
  对于<font color="red">作业</font>来说，不仅要考虑<font color="red">建立进程后的等待时间，还有加上作业在外存后备队列中等待的时间。</font>

### 8.5 响应时间
  <font color="red">相应时间</font>，指从用户<font color="red">提出请求</font>到<font color="red">首次产生响应</font>所用的时间。

## 九、FCFS、SJF、HRRN调度算法
  
### 9.1 先来先服务(FCFS)
  * 算法思想 `主要从"公平"的角度考虑`
  * 算法规则 `按照作业/进程到达的先后顺序进行服务`
  * 用于作业/进程调度
    > 用于作业调度时，考虑的是哪个作业先到达后备队列  
    > 用于进程调度时，考虑的是哪个进程先到达就绪队列
  * 是否可抢占 `非抢占的算法`
  * 优缺点
    > <font color="blue">优点</font>：公平、算法实现简单  
    > <font color="blue">缺点</font>：排在长作业（进程）后面的短作业需要等待很长时间，带权周转时间很大，对短作业来说用户体验不好。 <font color="red">对长作业有利，对短作业不利</font>
  * 是否会导致<font color="red">饥饿</font> `不会`

### 9.2 短作业优先(SJF)
  * 算法思想 `追求最少的平均等待时间，最少的平均周转时间、最少的平均带权周转时间`
  * 算法规则 `最短的作业/进程优先得到服务(所谓“最短”，是指要求服务时间最短)`
  * 用于作业/进程调度 `既可用于作业调度，也可用于进程调度。用于进程调度时成为“短进程优先（SPF,Shortest Process First）算法”`
  * 是否可抢占 `SJF和SPF是 非抢占式 的算法。但是也有 抢占式 的版本 -- 最短剩余时间优先算法（SRTN,Shortest Remaining Time Next）`
  * 优缺点
    > <font color="blue">优点</font>：公平、算法实现简单  
    > <font color="blue">缺点</font>：排在长作业（进程）后面的短作业需要等待很长时间，带权周转时间很大，对短作业来说用户体验不好。 <font color="red">对长作业有利，对短作业不利</font>
  * 是否会导致<font color="red">饥饿</font> `会`

### 9.3 高响应比优先(HRRN)

## 十、调度算法：时间片轮转、优先级调度、多级反馈队列

## 十一、进程同步、进程互斥

## 十二、进程互斥的软件实现

## 十三、进程互斥的硬件实现

## 十四、信号量机制

## 十五、用信号量实现进程互斥、同步、前驱关系

## 十六、生产者-消费者问题

## 十七、多生产者-多消费者问题

## 十八、吸烟者问题

## 十九、读者-写着问题

## 二十、哲学家进餐问题

## 二十一、管程

